// Model loader interface
// fabraham@tecgraf.puc-rio.br
#ifndef LOADER_NEW_H
#define LOADER_NEW_H

#include "unit.h"
#include <gpos/defines.h>
#include <gpos/common/util.h>
#include <stdio.h>

class ResModelNew;
class ResPosModelNew;

class RES_API ResPosLoaderNew
{
public:
  // Load error types
  enum LoadErrorType {
    BAD_FORMAT = 1,
    UNSUPPORTED_FILE_OPTIONS,
    DATA_UNAVAILABLE,
  };
public:
  ResPosLoaderNew ()
  : m_error_type(BAD_FORMAT)
  , m_ref_count(1)
  , m_opfunc(NULL)
  , m_opdata(NULL)
  , m_uspfunc(NULL)
  , m_uspdata(NULL)
  {
  }
  /**
   * Increases the reference counter of this object.
   */
  void IncRef ()
  {
    ++m_ref_count;
  }
  /**
   * Decreases the reference counter of this object.
   * If it reaches 0, the object is released.
   */
  void DecRef ()
  {
    if (--m_ref_count <= 0) {
      //printf("model will be released -> %d refs\n", m_ref_count);
      delete this;
    }
  }
  /**
   * Returns the type of error in case Load() returned false.
   */
  virtual LoadErrorType GetErrorType () const
  {
    return m_error_type;
  }
  virtual void SetOpenProfileFunc (SetOpenProfileCB cb, void* data)
  {
    m_opfunc = cb;
    m_opdata = data;
  }
  virtual void SetUpdateSectionProgressFunc (UpdateSectionProgressCB cb, void* data)
  {
    m_uspfunc = cb;
    m_uspdata = data;
  }
  virtual UpdateSectionProgressCB GetUpdateSectionProgressFunc () const
  {
    return m_uspfunc;
  }
  virtual void* GetUpdateSectionProgressFuncData () const
  {
    return m_uspdata;
  }
  virtual void SetLoadProfile (const char* profilename)
  {
    if (m_opfunc != NULL)
      m_opfunc(profilename, m_opdata);
  }
  virtual void UpdateProgress (const char *sectionname, float v)
  {
    if (m_uspfunc != NULL)
      m_uspfunc(sectionname, v, m_uspdata);
  }
  /**
   * Loads a result from the data source identified by 'src'
   * and fills the model data structure 'mdl' associated with the model of index
   * 'mdl->GetLoaderIndex()' (0 <= index < value returned by LoadHeader).
   * Please refer to the ResPosModelNew API to see which methods
   * must be called.
   * Returns 'true' in case of success and 'false' otherwise.
   */
  virtual bool Load (const char* src, ResPosModelNew* mdl) = 0;
  /**
   * Returns a load error description if any errors occurred.
   * Returns NULL if there is no such description.
   */
  virtual const char* GetLoadError () const
  {
    return NULL;
  }
  /**
   * Returns load error details if any errors occurred.
   * Returns NULL if there are no such details.
   */
  virtual const char* GetLoadErrorDetails () const
  {
    return NULL;
  }
  /**
   * Returns load warnings.
   * Returns NULL if there are no warnings.
   */
  virtual const char* GetLoadWarnings () const
  {
    return NULL;
  }
protected:
  /**
   * Protected destructor: object must be released through the reference
   * counter mechanism: Inc/DecRef.
   */
  virtual ~ResPosLoaderNew ()
  {
  }
  /**
   * Informs the error type in case of errors on Load().
   */
  void SetErrorType (LoadErrorType errortype)
  {
    m_error_type = errortype;
  }
private:
  LoadErrorType m_error_type;
  int m_ref_count;
  SetOpenProfileCB m_opfunc;
  void* m_opdata;
  UpdateSectionProgressCB m_uspfunc;
  void* m_uspdata;
};

/**
 * ResPosGeometryLoader
 *
 * This interface class determines which methods a geometry loader must
 * implement.
 *
 * The reservoir grid cells can be refined in equal parts in the 'i', 'j' and
 * 'k' directions. Refinements of a cell that resulted from a refinement are
 * also allowed.
 *
 * These refinements form a tree-like structure, where the root is the reservoir
 * itself and the children are the cells generated by each discretization
 * (including the initial discretization).
 *
 * The cell indices passed and received to this class methods are the position
 * of a cell in a breadth-first search beginning at the root of the tree minus
 * 1.
 * The node's children are ordered by the following rule:
 * - if cell1.k < cell2.k, then cell1 comes before cell2.
 * - if the 'k' are the same,
 *   if cell1.j < cell2.j, then cell1 comes before cell2.
 * - if the 'k' and 'j' are the same,
 *   if cell1.i < cell2.i, then cell1 comes before cell2.
 *
 * 2D Example (i axis top->bottom, j axis left->right):
 *
 *                    cell1         cell2
 * .---------------------------------------------------------------------.
 * |            | 10 | 11 | 12 | 19 | 20 | 21 |            |             |
 * |            |--------------|--------------|            |             |
 * |     0      | 13 | 14 | 15 | 22 | 23 | 24 |      3     |      4      |
 * |            |--------------|--------------|            |             |
 * |            | 16 | 17 | 18 | 25 | 26 | 27 |            |             |
 * |------------|--------------|--------------|------------|-------------|
 * |            |              |              |            |             |
 * |            |              |              |            |             |
 * |     5      |      6       |      7       |      8     |      9      |
 * |            |              |              |            |             |
 * |            |              |              |            |             |
 * \---------------------------------------------------------------------/
 *
 * Cell 23:
 * .--------------.
 * | 28 | 29 | 30 |   The root grid has NI=2, NJ=5. Cells 1 and 2 were refined
 * |--------------| in 3x3 parts. Cell 23 (child of I=0 J=2 with I=1 J=1) was
 * | 31 | 32 | 33 | also refined in 3x3 parts.
 * |--------------|
 * | 34 | 35 | 36 |
 * \--------------/
 */
class RES_API ResPosGeometryLoader : public ResPosLoaderNew
{
public:
  /**
   * Specifies loader version.
   * If version changes, previously cached .geom files are automatically invalidated.
   */
  virtual float GetVersion () const
  {
    return 0.0f;
  }
  /**
   * Informs if loader has complete mesh information (list of vertices and list of elements).
   * If not, GetCellVertices() will be called (loader has list of elements and its coordinates).
   */
  virtual bool HasMeshInformation () = 0;
  /**
   * In case HasMeshInformation() = true,
   * returns the number of mesh vertices.
   */
  virtual int GetVertexCount ()
  {
    return -1;
  }
  /**
   * In case HasMeshInformation() = true, returns the coordinates of the vertex
   * with index 'vertex_index'.
   * (0 <= vertex_index && vertex_index < GetVertexCount()).
   */
  virtual void GetVertexCoords (int vertex_index, float v[3])
  {
  }
  /**
   * In case HasMeshInformation() = true, returns the indices of the vertices
   * of cell 'cell_index'.
   * (0 <= vertices[n] && vertices[n] < GetVertexCount()).
   */
  virtual void GetCellVertices (int cell_index, int vertices[8])
  {
  }
  /**
   * This method must return the coordinates of the 8 cell vertices.
   *
   *                     0 ___a___ 1 _ x
   *                    /|        /|
   *                   / |       / |
   *                  i  d      j  b
   *                 /   |     /   |
   *                2 _____e_ 3    |
   *               /|    |    |    |
   *              y |    4 ___|c__ 5
   *                |   /     |   /
   *                h  k      f  l
   *                | /       | /
   *                |/        |/
   *                6 ____g__ 7
   *                     |
   *                     z
   *
   * The cell's index is passed.
   *
   * For all 8 vertices, where 'v' ranges from 0 to 7:\n
   * coords[3*v + 0] must be the 'x' coordinate of the vertex 'v'.\n
   * coords[3*v + 1] must be the 'y' coordinate of the vertex 'v'.\n
   * coords[3*v + 2] must be the 'z' coordinate of the vertex 'v'.\n
   */
  virtual void GetCellVertices (int index, float coords[24]) = 0;
  /**
   * Returns the filenames used to load the geometry from data source 'src'.
   *
   * Places the result in '*numfiles' and '*filenames'.
   * Memory for '*filenames' and '*(filenames)[i]' should be allocated with malloc/calloc/realloc.
   */
  virtual void GetFilenames (const char *src,
                             int        *numfiles,
                             char     ***filenames) = 0;
protected:
  /**
   * Protected destructor: object must be released through the reference
   * counter mechanism: Inc/DecRef.
   */
  virtual ~ResPosGeometryLoader ()
  {
  }
  /**
   * Utility function: if HasMeshInformation() = true, can be used
   * to correctly respond to the GetCellVertices(int, float[24]) method.
   */
  void GetCellVerticesCoordsFromMesh (int index, float coords[24])
  {
    int vertex_indices[8];
    GetCellVertices(index, vertex_indices);
    for (int n=0; n<8; ++n)
      GetVertexCoords(vertex_indices[n], coords + n*3);
  }
};

/**
 * ResPosResultLoader
 *
 * This interface class determines which methods map and well result loaders must
 * implement.
 */
class RES_API ResPosResultLoader : public ResPosLoaderNew
{
public:
  /**
   * Loads the basic information of a result from the data source identified by 'src'.
   * Must return true in case of success and false in case of failure.
   *
   * Additionally, if loader has this sort of information,
   * *model_count can be set to the number of models associated with 'src'.
   * If 'src' has more than 1 model, *suffixes must be allocated (with new[]) to contain
   * 'model_count' suffix strings.
   *
   * If loader does not have this sort of information, *model_count and *suffixes do not
   * have to be changed, and it will be assumed only 1 model without a suffix is to be
   * created.
   *
   * Method will be called before 'Load'.
   */
  virtual bool LoadHeader (const char* src, int* model_count, char*** suffixes) = 0;
protected:
  /**
   * Protected destructor: object must be released through the reference
   * counter mechanism: Inc/DecRef.
   */
  virtual ~ResPosResultLoader ()
  {
  }
};

/**
 * ResPosMapResultLoader
 *
 * This interface class determines which methods a map result loader must
 * implement.
 */
class RES_API ResPosMapResultLoader : public ResPosResultLoader
{
public:
  virtual bool LoadIniProperty (ResPosModelNew* mdl, int prop_id, float* data) = 0;
  virtual bool LoadRecProperty (ResPosModelNew* mdl, int prop_id, int ts, float* data) = 0;
protected:
  /**
   * Protected destructor: object must be released through the reference
   * counter mechanism: Inc/DecRef.
   */
  virtual ~ResPosMapResultLoader ()
  {
  }
};

/**
 * ResPosWellResultLoader
 *
 * This interface class determines which methods a well result loader must
 * implement.
 */
class RES_API ResPosWellResultLoader : public ResPosResultLoader
{
public:
  /**
   * Obtains a simulator specific description for the completion in the model.
   * Default: simply its index in the well list.
   */
  virtual char* GetCompletionName (ResPosModelNew* mdl, 
                                   int well_id,
                                   int comp_index) 
  {
    char name[1024];
    sprintf(name,"%d",comp_index+1);
    return PSUtil::StrDup(name);
  }
  /**
   * Informs which time steps are recorded for well property 'prop_id', well 'well_id'.
   * Returns true if successful or false if failed fetching this data.
   */
  virtual bool GetWellPropRecordedSteps (ResPosModelNew* mdl,
                                         int prop_id,
                                         int well_id,
                                         bool* has_recorded_steps) = 0;
  /**
   * Informs which time steps are recorded for completion property 'prop_id', well 'well_id'
   * and completion index 'comp_index'.
   * Returns true if successful or false if failed fetching this data.
   */
  virtual bool GetCompletionPropRecordedSteps (ResPosModelNew* mdl,
                                               int prop_id,
                                               int well_id,
                                               int comp_index,
                                               bool* has_recorded_steps) = 0;
  /**
   * Informs which time steps are recorded for group property 'prop_id', group 'group_id'.
   * Returns true if successful or false if failed fetching this data.
   */
  virtual bool GetGroupPropRecordedSteps (ResPosModelNew* mdl,
                                          int prop_id,
                                          int group_id,
                                          bool* has_recorded_steps) = 0;
  /**
   * Informs which time steps are recorded for region property 'prop_id', region 'region_id'.
   * Returns true if successful or false if failed fetching this data.
   */
  virtual bool GetRegionPropRecordedSteps (ResPosModelNew* mdl,
                                           int prop_id,
                                           int region_id,
                                           bool* has_recorded_steps) = 0;
  /**
   * Informs which time steps are recorded for field property 'prop_id'.
   * Returns true if successful or false if failed fetching this data.
   */
  virtual bool GetFieldPropRecordedSteps (ResPosModelNew* mdl,
                                          int prop_id,
                                          bool* has_recorded_steps) = 0;
  /**
   * Informs which time steps are recorded for extra property 'prop_id'.
   * Returns true if successful or false if failed fetching this data.
   */
  virtual bool GetExtraPropRecordedSteps (ResPosModelNew* mdl,
                                          int prop_id,
                                          bool* has_recorded_steps) = 0;
  virtual bool LoadWellProperty (ResPosModelNew* mdl,
                                 int prop_id,
                                 int well_id,
                                 float* data) = 0;
  virtual bool LoadCompletionProperty (ResPosModelNew* mdl,
                                       int prop_id,
                                       int well_id,
                                       int comp_index,
                                       float* data) = 0;
  virtual bool LoadGroupProperty (ResPosModelNew* mdl,
                                  int prop_id,
                                  int group_id,
                                  float* data) = 0;
  virtual bool LoadRegionProperty (ResPosModelNew* mdl,
                                   int prop_id,
                                   int region_id,
                                   float* data) = 0;
  virtual bool LoadFieldProperty (ResPosModelNew* mdl, int prop_id, float* data) = 0;
  virtual bool LoadExtraProperty (ResPosModelNew* mdl, int prop_id, float* data) = 0;
protected:
  /**
   * Protected destructor: object must be released through the reference
   * counter mechanism: Inc/DecRef.
   */
  virtual ~ResPosWellResultLoader ()
  {
  }
};

#endif

