/* 
 * Copyright 2007 Orad Hi-Tec Systems Ltd.
 * ALL RIGHTS RESERVED
 *
 * Filename: dvgAPIBase.hpp
 */

#ifndef _DVG_A_P_I_BASE_HPP
#define _DVG_A_P_I_BASE_HPP

#include "dvgAPICommon.hpp"
#include "DvgAPIDefs.hpp"

/**
Base class for APIs to DVG functionality.

Static methods can be used before open any object to determine number and types of installed boards.
Most of methods in DVG APIs can be used only after opening API. 
Each object entity represents one DVG board.
Board is choosen in open() method and not changed after that. 
It is possible to close API and reopen for other board, but it is recomended to create separate objects for each DVG board.

There are methods to retrieve information about board, driver or service
and method which represent common functionality of DVG system.
*/

class ElStaticPart;
class ElStaticBoard;

class DVGAPI_SHARED_SYMBOL dvgAPIBase
  {
public:

  enum StatusCodes
    {
    SUCCESS = 0,
    UNSUPPORTED_CAPABILITY                   = -500,
    ERROR_PARAMETER_VALUE                    = -499,
    DRIVER_NOT_STARTED                       = -498,
    DRIVER_FAILURE                           = -497,
    DRIVER_CLOSE_FAILURE                     = -496,
    CREATE_OVERLAPED_EVENT_FAILURE           = -495,
    CREATE_SWAP_EVENT_FAILURE                = -494,
    SWAP_EVENT_NOT_SET                       = -493,
    CREATE_INTERRUPT_EVENT_FAILURE           = -492,
    INTERRUPT_EVENT_NOT_SET                  = -491,
    SWAP_COUNTER_NOT_SET                     = -490,
    CHANGES_NOTIFICATION_NOT_SET             = -489,
    DRIVER_IO_ERROR                          = -488, // Specified system error you may get by getSystemErrorCode()
    SWAP_TIMEOUT                             = -487,
    WAITING_TIMEOUTED = SWAP_TIMEOUT,
    SWAP_FAILED                              = -486,
    WAITING_FAILED = SWAP_FAILED,
    CREATE_COMMUNICATION_FAILURE             = -485,
    API_NOT_OPEN                             = -484,
    DRIVER_FW_NOT_LOADED                     = -483,
    CREATE_SWAP_BARRIER_READY_EVENT_FAILURE  = -482,
    CREATE_SWAP_BARRIER_WAIT_EVENT_FAILURE   = -481,
    MESSAGES_SERVICE_FAILURE                 = -480,
    NO_MAIN_DVG_BOARD                        = -479,
    REQUEST_FAILED                           = -478,
    REQUEST_CANCELED                         = -477,
    CRITICAL_SECTION_FAILURE                 = -476,
    SERVICE_IO_ERROR                         = -475,
    FUNCTIONALITY_NOT_INITIALIZED            = -474,
    SERVICE_NOT_RESPONDING                   = -473,
    L2BUFFER_ALREADY_EXISTS                  = -472,
    L2BUFFER_BUSY                            = -471,
    END_OF_STATUS_CODES   = -470
    };

  /// Constant values used in this class.
  enum Consts
    {
    /// Used to choose first compositor (main) DVG board in system.
    MAIN_DVG_BOARD_INDEX = -1,
    };

   /** 
  Default constructor.
  It initialize all the internal struct.
  Pleas use getStatus() method to check that initialization finish succesfuly.
  */
  dvgAPIBase(void);

  /// Destructor.
  virtual ~dvgAPIBase(void);

   /**
  Returns number of DVG boards detected in system.
  Boards are indexed from 0 to aNum - 1.
  */
  static StatusCodes getNumberOfBoards(unsigned int &aNum);

  /**
  Returns description of DVG board. It allows check board type and open appropriate API(s).
  Boards are indexed from 0.
  */
  static StatusCodes getBoardCapability(const unsigned int aBoardIndex, const DvgAPIDefs::DVGBoardCapability* &aBoardCap);
 
  /**
  Returns true if given board is initialized and works.
  */
  static bool isInitialized(const unsigned int aBoardIndex);

  /**
  Returns true if given board is a compositor.
  */
  static bool isCompositor(const unsigned int aBoardIndex);

#ifndef DVGAPI_DISABLE_GRABBER
  
  /**
  Returns true if given board is a grabber.
  */
  static bool isGrabber(const unsigned int aBoardIndex);

#endif //DVGAPI_DISABLE_GRABBER

  /**
  This method return last status code (which was returned by last method call).
  See StatusCodes definition.
  */
  StatusCodes getStatus(void) const;

  /**
  This method return string description for given status code 
  (returned by any called method) or NULL if the value is out of the range.
  If called without parameters, return description about last status 
  (like returned by getStatus() method).
  */
  virtual const char *getStatusString(const StatusCodes aStatusCode = END_OF_STATUS_CODES) const;

  /**
  This method return last system error code generated by called method.
  Can be used only if last called method return error status code (not SUCCESS).
  Then can get more information about the problem.
  See windows GetLastError() function for meaning of the codes.
  */
  int getSystemErrorCode(void) const;

  /**
  Check if dvg service is working.
  aLiveTime - timeout in miliseconds from last alive event, 0 for system default timeout.
  Returns SERVICE_NOT_RESPONDING when service alive event was not registered for aLiveTime or more,
  or SUCCESS in other case.
  */
  StatusCodes isServiceAlive(unsigned int aLiveTime = 0);


  /**
  This method try to open connection to the aBoard.
  Must be executed before use on any methods below.
  Can be call more than one time (next call first call close() method, then reopen all connection).
  Boards are indexed from 0.
  MAIN_DVG_BOARD_INDEX special value can be used to open firsty compositor board into system.
  It returns StatusCodes error code.
  */
  StatusCodes open(const int aBoardIndex);

  /**
  It return board index which was open.
  Boards are indexed from 0.
  If no open board, return error code.
  */
  StatusCodes getBoardIndex(int &aBoardIndex);

  /**
  This close connection to the driver.
  It is executed into destructor and open() automatically.
  It return StatusCodes error code.
  */
  StatusCodes close(void);

  /**
  This method return true if open() was executed and close() was not called after.
  */
  bool isOpen(void) const
    { return theIsOpen; };

  /**
  This method return true if last open() execute succeed and close() was not call after.
  */
  bool isOK(void) const
    { return theIsOK; };

  /**
  Returns description of opened DVG board.
  */
  StatusCodes getBoardCapability(const DvgAPIDefs::DVGBoardCapability*&);

  /**
  Returns true if opened board is a compositor.
  */  
  bool isCompositor(void);

#ifndef DVGAPI_DISABLE_GRABBER

  /**
  Returns true if opened board is a grabber.
  */
  bool isGrabber(void);

#endif //DVGAPI_DISABLE_GRABBER

  /**
  This function return version of the used API library.
  @param aMajor      - a major version number.
  @param aMinor      - a minor version number.
  @param aRevision   - a revision number.
  @return  - a StatusCodes error code.
  */
  StatusCodes getVersion(unsigned &aMajor, unsigned &aMinor, unsigned &aRevision);

  /**
  This function return version of DVG service working on this machine.
  @param aMajor      - a major version number.
  @param aMinor      - a minor version number.
  @param aRevision   - a revision number.
  @return  - a StatusCodes error code.
  */
  StatusCodes getServiceVersion(unsigned &aMajor, unsigned &aMinor, unsigned &aRevision);

  /**
  This function return version of DVG driver working on this machine.
  @param aMajor      - a major version number.
  @param aMinor      - a minor version number.
  @param aRevision   - a revision number.
  @return  - a StatusCodes error code.
  */
  StatusCodes getDriverVersion(unsigned &aMajor, unsigned &aMinor, unsigned &aRevision);
 
  /**
  This function return version of DVG firmware loaded on the DVG board.
  @param aVersion    - a version of DVG board number.
  @param aRevision   - a Revision of DVG board number.
  @param aPatchLevel - a patch level for given revision version.
  @return  - a StatusCodes error code.
  */
  StatusCodes getFirmwareVersion(unsigned &aVersion, unsigned &aRevision, unsigned &aPatchLevel);


  /**
  This method starts measurement of specific statistics category.
  It return StatusCodes error code.
  */
  StatusCodes startMeasure(const DvgAPIDefs::StatsCategories aStatsCategory);

  /**
  This method ends measurement of specific statistics category.
  It return StatusCodes error code.
  */
  StatusCodes endMeasure(const DvgAPIDefs::StatsCategories aStatsCategory);

  /**
  This method returns last second statistics information of specific category.
  It reset sum time and counter (to be ready for next statistics).
  @param aMinTime - minimum single measurement in microseconds.
  @param aMaxTime - maximum single measurement in microseconds.
  @param aSumTime - sum of all measurements in microseconds.
  @param aCount - number of measurements.
  It return StatusCodes error code.
  */
  StatusCodes getStats(const DvgAPIDefs::StatsCategories aStatsCategory, unsigned long &aMinTime, unsigned long &aMaxTime, unsigned long &aSumTime, unsigned long &aCount);

  /**
  This method returns last measurement of specific statistics category.
  @param aLastTime - measurement in microseconds.
  It return StatusCodes error code.
  */
  StatusCodes getLastTime(const DvgAPIDefs::StatsCategories aStatsCategory, unsigned long &aLastTime);

  /**
  This method returns current measurement's counter of specific statistics category.
  Counter is increased by one after each new statistic from last second is prepared.
  It return StatusCodes error code.
  */
  StatusCodes getStatsCounter(const DvgAPIDefs::StatsCategories aStatsCategory, unsigned long &aCounter);

  /**
  This method returns user debug flags in aFlags parameter.
  Meaning of those flags are up to user application.
  Flags can be set from Message Viewer GUI.
  It return StatusCodes error code.
  */
  StatusCodes getUserDebugFlags(unsigned int &aFlags);

  /**
  This method is used to write user message in given category to remote Message Viewer GUI.
  aCategory parameter defines one of categories from DVGDebugCategory enum.
  aMessage point to null-terminated string with message to write. 
  It returns StatusCodes error code.
  */
  StatusCodes writeUserMessage(const DvgAPIDefs::DVGDebugCategory aCategory, const char* aMessage);

  /**
  This method is used to write user message in given category to remote Message Viewer GUI.
  aCategory parameter define one of categories from DVGDebugCategory enum.
  aFormat point to a string defining format in printf() - like form.
  Rest of parameters are variable, as defined in aFormat. 
  It returns StatusCodes error code.
  */
  StatusCodes writeUserMessageEx(const DvgAPIDefs::DVGDebugCategory aCategory, const char* aFormat, ...);

  /**
  This method is used to write user message in given category to remote Message Viewer GUI.
  aCategory parameter define one of categories from DVGDebugCategory enum.
  aFormat point to a string defining format in printf()-like form.
  aArags defines list of arguments - like in vsprintf() call. 
  It returns StatusCodes error code.
  */
  StatusCodes writeUserMessageEx(const DvgAPIDefs::DVGDebugCategory aCategory, const char* aFormat, va_list aArgs);

  /**
  Helper function which return true if given video format aFormat is progressive.
  */
  static bool isVideoFormatProgressive(const DvgAPIDefs::DVGGraphicsMode aFormat);

  /**
  Helper function which return string description for given video format (graphics mode).
  */
  static const char *getVideoFormatString(const DvgAPIDefs::DVGGraphicsMode aFormat);

  /**
  Helper function which return string description for given channel addtive function.
  */
  static const char *getAdditiveFunctionString(const DvgAPIDefs::DVGAdditiveFunction aFunction);


protected:

  enum
    {
    // 500 ms.
    SHORT_NOTIFICATION_TIMEOUT = 500,
    // 5 sec.
    OPEN_SERVICE_TIMEOUT = 5000,
    };

  virtual StatusCodes preOpening(void)
    { return SUCCESS; };

  virtual StatusCodes opening(void) = 0;
  virtual StatusCodes closing(void) = 0;
  StatusCodes setVideoFormat(const DvgAPIDefs::DVGGraphicsMode aFormat);
  StatusCodes getVideoFormat(DvgAPIDefs::DVGGraphicsMode& aFormat);
  StatusCodes getSolution(struct DVGSolution& aSolution);

  StatusCodes theStatus;
  int theErrorCode;
  bool theIsOpen;
  bool theIsOK;
  int theBoardIndex;
  OVERLAPPED theOverlappedStruct;

  bool checkOverlappedResult(OVERLAPPED &aOverlappedStruct, const bool aWait = true);
  unsigned int checkChanges(const unsigned int aFlag, const bool aInternal = true);

  inline unsigned getTimeDiff(const __int64 aStart, const __int64 aStop)
    {
    return (unsigned int)((aStop - aStart) * 1000000 / timerResolution);
    }

  inline void getTimestamp(__int64 &aStamp)
    {
    QueryPerformanceCounter((LARGE_INTEGER *)&aStamp);
    }

  ElStaticBoard *theBoard;

  unsigned int theInternalChangesFlags;
  unsigned int theExternalChangesFlags;
  __int64 timerResolution;
  __int64 currentTimeStamp;

  static ElStaticPart* theStaticPart;

  bool isAPIDataOpen(void) const
    { return theAPIDataOpen; }

  bool openRWServiceData(void);

  bool isServiceDataOpen(const bool aReadOnly) const
    { return aReadOnly? theROServiceDataOpen: theRWServiceDataOpen; }

  bool openServiceInputRing(void);
  bool openResultNotification(void);
  void putCommand(class DVGServiceCommStruct& aCommand);
  StatusCodes waitForResult(int aTimeout = -1);
  static void createStaticPart(void);
  class DVGServiceCommStruct* theServiceCommand;

private:

  bool openAPIData(void);
  bool openROServiceData(void);
  bool createOverlapedEvent(void);

  /// Copy constructor is private, do not use it.
  dvgAPIBase(const dvgAPIBase &aOther);
  /// = operator is private, do not use it.
  dvgAPIBase &operator=(const dvgAPIBase &aOther);

  enum
    {
    // 60 secs
    DEFAULT_NOTIFICATION_TIMEOUT = 60000,
    MAX_STATUS_CODES = (END_OF_STATUS_CODES - UNSUPPORTED_CAPABILITY) + 1
    };

  HANDLE theOpenSection;
  bool theAPIDataOpen;
  bool theROServiceDataOpen;
  bool theRWServiceDataOpen;
  bool theServiceInputRingOpen;
  class ElResultNotificationClient *theResultNotification;
  unsigned int theNotificationTimeout;
  unsigned int theAPIId;
  unsigned int theCurrentBlockNumber;

  static const char *theStatusStrings[MAX_STATUS_CODES];
  static const char *theGraphicsModeStrings[DvgAPIDefs::DVG_GRAPHICS_MODE_COUNT];
  static const char *theAdditiveFunctionStrings[DvgAPIDefs::DVG_ADD_FUN_COUNT];
  };

#endif
